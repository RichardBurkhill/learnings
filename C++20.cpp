/**
 * @file C++20.cpp
 * @brief Demonstrates various C++20 language constructs and features.
 *
 * This file showcases key C++20 additions including:
 * - Concepts
 * - Ranges library
 * - Coroutines
 * - `std::format`
 * - `std::span`
 * - `std::numbers` (mathematical constants)
 */

#include <iostream>
#include <vector>
#include <ranges>        ///< C++20: Ranges library for declarative view composition.
#include <concepts>      ///< C++20: Concepts for compile-time validation of template parameters.
#include <numbers>       ///< C++20: Mathematical constants like std::numbers::pi.
#include <coroutine>     ///< C++20: Coroutines for resumable functions.
#include <optional>
#include <format>        ///< C++20: std::format for safe and extensible text formatting.
#include <span>          ///< C++20: std::span for safe, non-owning views over contiguous sequences.
#include <type_traits>

// --------------------------
/**
 * @brief Concept to check if a type is numeric.
 *
 * @tparam T The type to check.
 * @concept Numeric
 * @details This concept uses `std::is_arithmetic_v` to ensure that a type `T`
 *          is an arithmetic type (e.g., int, float, double).
 */
template<typename T>
concept Numeric = std::is_arithmetic_v<T>;

/**
 * @brief Calculates the square of a numeric value.
 *
 * @tparam T The type of the input value, constrained by the `Numeric` concept.
 * @param x The input value.
 * @return The square of the input value.
 * @details This function demonstrates the use of C++20 Concepts to constrain
 *          template parameters, ensuring that `square` can only be called
 *          with numeric types.
 */
Numeric auto square(Numeric auto x) { ///< C++20: Constrained function template using a concept.
    return x * x;
}

/**
 * @brief A simple coroutine generator.
 *
 * @tparam T The type of values yielded by the generator.
 * @details This `Generator` struct provides a basic implementation of a C++20
 *          coroutine, allowing for lazy generation of sequences.
 */
template<typename T>
struct Generator {
    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;

    struct promise_type {
        T current_value;
        auto get_return_object() { return Generator{handle_type::from_promise(*this)}; }
        auto initial_suspend() { return std::suspend_always{}; } ///< C++20: Coroutine initial suspension point.
        auto final_suspend() noexcept { return std::suspend_always{}; } ///< C++20: Coroutine final suspension point.
        void unhandled_exception() { std::exit(1); }
        auto yield_value(T value) { ///< C++20: Coroutine yield point.
            current_value = value;
            return std::suspend_always{};
        }
        void return_void() {}
    };

    handle_type coro;
    Generator(handle_type h) : coro(h) {}
    ~Generator() { if (coro) coro.destroy(); }

    /**
     * @brief Resumes the coroutine and returns the next yielded value.
     *
     * @return The next value generated by the coroutine.
     */
    T next() {
        coro.resume();
        return coro.done() ? T{} : coro.promise().current_value;
    }
};

/**
 * @brief A coroutine that generates a sequence of integers from 0 up to `max`.
 *
 * @param max The maximum value to generate.
 * @return A `Generator<int>` instance.
 * @details This function demonstrates a simple C++20 coroutine that uses `co_yield`
 *          to produce a sequence of numbers.
 */
Generator<int> counter(int max) {
    for (int i = 0; i <= max; ++i)
        co_yield i; ///< C++20: co_yield keyword for coroutine value generation.
}

/**
 * @brief Main function demonstrating C++20 features.
 *
 * This function showcases:
 * - Usage of `std::format` for string formatting.
 * - Concepts for constraining template functions.
 * - Ranges for functional-style data processing.
 * - `std::span` for safe array views.
 * - Coroutines for generating sequences.
 * - `std::numbers` for mathematical constants.
 */
int main() {
    std::cout << std::format("Square of {} is {}\n", 5, square(5)); ///< C++20: std::format for modern string formatting.
    std::cout << std::format("Ï€ squared is {:.5f}\n", square(std::numbers::pi)); ///< C++20: std::numbers for mathematical constants.

    // Ranges: filter + transform
    std::vector<int> nums{1, 2, 3, 4, 5, 6};
    /**
     * @brief Demonstrates C++20 Ranges for filtering and transforming a vector.
     *
     * This chain of operations filters even numbers and then squares them,
     * all in a declarative style.
     */
    auto even_squares = nums | std::views::filter([](int n) { return n % 2 == 0; }) ///< C++20: std::views::filter for range-based filtering.
                             | std::views::transform([](int n) { return n * n; }); ///< C++20: std::views::transform for range-based transformation.

    std::cout << "Even squares: ";
    for (int x : even_squares)
        std::cout << x << " ";
    std::cout << "\n";

    // Span (non-owning view)
    int raw_array[] = {10, 20, 30, 40};
    std::span<int> view(raw_array); ///< C++20: std::span for safe, non-owning array views.
    std::cout << "Span contents: ";
    for (int x : view)
        std::cout << x << " ";
    std::cout << "\n";

    // Coroutines: simple counter
    std::cout << "Counting to 5 using coroutine:\n";
    auto gen = counter(5);
    for (int i = 0; i <= 5; ++i)
        std::cout << gen.next() << " ";

    std::cout << "\n";
    return 0;
}
